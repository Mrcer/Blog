<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>咩咩的博客</title>
  
  
  <link href="https://mrcer.gitee.io/Blog/atom.xml" rel="self"/>
  
  <link href="https://mrcer.gitee.io/Blog/"/>
  <updated>2024-03-31T15:26:35.544Z</updated>
  <id>https://mrcer.gitee.io/Blog/</id>
  
  <author>
    <name>咩咩</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从离奇bug到C++未定义行为</title>
    <link href="https://mrcer.gitee.io/Blog/2024/03/31/%E4%BB%8E%E7%A6%BB%E5%A5%87bug%E5%88%B0C-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA/"/>
    <id>https://mrcer.gitee.io/Blog/2024/03/31/%E4%BB%8E%E7%A6%BB%E5%A5%87bug%E5%88%B0C-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA/</id>
    <published>2024-03-31T13:55:28.000Z</published>
    <updated>2024-03-31T15:26:35.544Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从离奇bug到C-未定义行为"><a href="#从离奇bug到C-未定义行为" class="headerlink" title="从离奇bug到C++未定义行为"></a>从离奇bug到C++未定义行为</h1><p>这是发生于2022年12月18日凌晨的事情，起因也许是数据结构课的某道算法题吧，遇到了非常离奇的bug，最后在群友们专家会诊两小时后找到了原因。现在我用聊天记录尽可能还原当时场景。</p><h2 id="开端"><a href="#开端" class="headerlink" title="开端"></a>开端</h2><p>这是一条很普通的算法题，大概是用先序遍历和中序遍历还原二叉树。下面是我写的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">    <span class="type">int</span> l;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Node&gt; tree;</span><br><span class="line">string sa, sb;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> al, <span class="type">int</span> ar, <span class="type">int</span> bl, <span class="type">int</span> br)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> index = tree.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> bpos = bl;</span><br><span class="line">    <span class="keyword">while</span>(sb[bpos] != sa[al]) bpos++;</span><br><span class="line">    <span class="type">int</span> llen=bpos-bl, rlen=br-bpos;</span><br><span class="line">    Node n;</span><br><span class="line">    n.c = sa[al];</span><br><span class="line">    n.w = llen == <span class="number">0</span> &amp;&amp; rlen == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    tree.<span class="built_in">push_back</span>(n);</span><br><span class="line">    <span class="keyword">if</span>(llen != <span class="number">0</span>) &#123;</span><br><span class="line">        tree[index].l = <span class="built_in">build</span>(al+<span class="number">1</span>, al+llen, bl, bl+llen<span class="number">-1</span>);</span><br><span class="line">        tree[index].w += tree[tree[index].l].w;</span><br><span class="line">    &#125; <span class="keyword">else</span> tree[index].l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(rlen != <span class="number">0</span>) &#123;</span><br><span class="line">        tree[index].r = <span class="built_in">build</span>(al+llen+<span class="number">1</span>, ar, bl+llen+<span class="number">1</span>, br);</span><br><span class="line">        tree[index].w += tree[tree[index].r].w;</span><br><span class="line">    &#125; <span class="keyword">else</span> tree[index].r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; tree[n].w ; i++) cout &lt;&lt; tree[n].c;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span>(tree[n].l != <span class="number">0</span>) <span class="built_in">print</span>(tree[n].l);</span><br><span class="line">    <span class="keyword">if</span>(tree[n].r != <span class="number">0</span>) <span class="built_in">print</span>(tree[n].r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; sa &gt;&gt; sb;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">0</span>, sa.<span class="built_in">size</span>()<span class="number">-1</span>, <span class="number">0</span>, sb.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来很普通，然而我发现哪怕是输入<code>AB AB</code>，程序都会发生段错误，诡异的是……</p><img src="gdb1.png"/><p>可以看到在第 29 行代码处，<code>tree[index].r</code>被<code>build</code>赋的值竟然是非法的，而前面按步执行明明是合法的！</p><p>“更玄学的是，如果开个临时变量保存返回值再赋值回去，就没事了”</p><p>群友们陆续出动，纷纷在自己的电脑上跑了一下代码，有的段错误，有的却正常运行……</p><p>难道，是编译器有bug？</p><h2 id="会诊"><a href="#会诊" class="headerlink" title="会诊"></a>会诊</h2><p>虽然从聊天记录里看不出来，但其实作为有点内向的我，发问前一定已经做了充分的研究。我已经大概猜到要到汇编层面才能寻找到答案，然而苦于没有合适工具</p><p>radare坏了，ida不会用，静态分析看不懂，真的很菜（）</p><p>群友Fox用clang挂ASAN没有扫到内存错误，建议继续挂调试器找内存错误原因<br>群友GZ复现了错误，正在配置调试环境<br>群友c猜测是逻辑错误<br>群友jy查看后台，初露端倪：</p><p>“草，确实有可能是 gcc 的问题，刚刚看了下：<br>他 wsl 是 gcc 9<br>测评是 gcc 10<br>我 ubt 22.04 是 gcc 11<br>我 mingw 是 gcc 12”</p><p>我发问前应该已经调试了一下午了，都已经爬上床准备睡了，看到群友们干劲十足，自己也不好意思干等着，麻溜地爬下床测试程序复现bug，真的好冷QAQ。</p><p>Fox不相信是 gcc 的问题，而GZ沿着这条线索开始深入汇编寻找真相……</p><p>如此玄学的bug，我不禁想起前不久B站某次<a href="https://www.bilibili.com/read/cv17521097/">夜间大规模崩溃报告</a>，最终原因竟然是一小段lua代码，在某种情况下以错误的参数调用了 _gcd 函数，导致死循环。</p><h2 id="揭示"><a href="#揭示" class="headerlink" title="揭示"></a>揭示</h2><p>随着群友们深入汇编，答案即刻浮现。</p><p>Fox使用 <a href="https://godbolt.org/">Compiler Explorer</a> 为我们揭示了答案：</p><img src="1711896716714.png"/><img src="1711896737238.png"/><p>可以看到，g++10 和 g++12 在 <code>tree[index].r = build(al+llen+1, ar, bl+llen+1, br);</code> 处编译结果并不相同。</p><p>汇编也许有点难度，但只看红色部分，我们不难发现有两个操作的顺序是反的！也就是 <code>build(int, int, int, int)</code> 和 <code>std::vector&lt;Node, std::allocator&lt;Node&gt; &gt;::operator[](unsigned long)</code></p><p>前面这个好理解，就是赋值前函数运算，后面这个是……</p><p>对喔！tree 是一个 vector ，那么它的下标运算符当然是运算符重载函数，这样一来段错误的原因就很明显了！</p><p>在编译器眼里这条语句就相当于 <code>f() = g()</code>，因为 C++ 标准并未规定相同优先级的函数谁先执行，从左到右执行应当是很合理的。<br>然而在这里，这样就相当于先执行下标引用再执行<code>build</code>。<br>一般而言，这不会带来什么问题，但在这里，<code>build</code>是一个递归函数，<code>tree</code>完全有可能会在<code>build</code>执行过程中被插入数据，导致容器大小改变。<br>而<code>vector</code>大小一旦超过预分配的内存，就会触发扩容，如此一来先前调用下标引用得到的地址就会无效！</p><p>未定义行为！是未定义行为！</p><h2 id="散会"><a href="#散会" class="headerlink" title="散会"></a>散会</h2><p>后来我们好像查到，是有人反馈过这个问题，g++在后来就“修复”了这个bug</p><p>然而从原理上讲，好像又不能怪罪g++，毕竟确实是未定义行为。</p><p>如果要总结什么教训的话，或许就是应该意识到，在享受C++运算符重载便利的同时，也应当注意到它终究是个函数，可能会带来意想不到的情形吧。<br>好像还有点关于副作用函数的关联，但因为不太了解，就按下不表了。<br>总之，将容器解引用放在等号左边前请三思。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这篇文章是靠事后回忆写成的，我的印象也很模糊了，但揭示真相时还是很震撼。</p><p>前面的铺垫可能太短了，毕竟我文笔不好也没记不清，但我得说，参与讨论的几位群友直到现在我都觉得是很厉害的大佬，他们围绕这个问题在新年前深夜足足讨论了两小时！</p><p>希望能给你带来新的思考~</p>]]></content>
    
    
    <summary type="html">一直答应要写的博客终于在今天开始写啦！</summary>
    
    
    
    
    <category term="技术杂谈" scheme="https://mrcer.gitee.io/Blog/tags/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>夕阳与晚霞</title>
    <link href="https://mrcer.gitee.io/Blog/2024/03/31/%E5%A4%95%E9%98%B3%E4%B8%8E%E6%99%9A%E9%9C%9E/"/>
    <id>https://mrcer.gitee.io/Blog/2024/03/31/%E5%A4%95%E9%98%B3%E4%B8%8E%E6%99%9A%E9%9C%9E/</id>
    <published>2024-03-31T12:16:13.000Z</published>
    <updated>2024-03-31T13:58:44.170Z</updated>
    
    <content type="html"><![CDATA[<p>背景是 Plasma 6 的壁纸，由 axo1otl 创作的 Scarlet Tree</p><h1 id="夕阳与晚霞"><a href="#夕阳与晚霞" class="headerlink" title="夕阳与晚霞"></a>夕阳与晚霞</h1><p>每天傍晚下课都能在水天交接处看到，夕阳将半天云朵晕成橘红。<br>这时我会很想将它描绘下来，甚至好几次驻足采色，然后回去还是继续学习或玩游戏。<br>大概很多我想做的事也是这样被搁浅的吧。</p><h2 id="夕阳"><a href="#夕阳" class="headerlink" title="夕阳"></a>夕阳</h2><p>时间过得好快，我进入大学已经学了好多东西，认识了好多人。我知道得更多，却也更迷茫了。</p><p>我看到了很多人：<br>有的很坚定地要当大科学家，于是成为我眼中的大卷王，早晚将课程研究到极致；<br>有的凭自己的心前进，去追寻有趣的知识与技术，创作自己的作品；<br>有的不将自己困于专业，去探索艺术，去写书，去上山研究易经。<br>他们的精彩我列不完，很幸运能遇见如此有趣的人。</p><p>我总是问自己，你想要过怎样的人生呢？追求探索创造美好，远离批判对抗压迫，如此种种。<br>然而某些时候我愈加感到疲惫，自己终究不是圣人，在劳累一天后我很难焚香沐浴留下所感所想，面对世间苦难除了愤慨好像也做不了太多。<br>也许在成长过程中，有形的枷锁已然在心中留下痕迹，即便卸下也很难摒除其力量。</p><p>不过乐观点想，我也的确在进步，虽然走得不快，方向大致没错。</p><h2 id="晚霞"><a href="#晚霞" class="headerlink" title="晚霞"></a>晚霞</h2><p>好久没有更博客和知识笔记了，一方面是上面的原因，另一方面也是觉得网上信息已经很多，我恐怕没必要在这感动自己，而且笔记整理实在辛苦。</p><p>不过最近我随意记下的漫笔竟然有人看到，实在受宠若惊。想来网上信息纷纭，能找到我也是一种缘分。</p><p style="display:none">可惜我的外壳日渐坚硬，思想愈发混沌，情绪也越来越差，恐怕我很难破茧出来大方迎客。</p><p>所以我决定近日有空更几篇博客，也算是表示一点感谢。</p><p>该停下来涂抹夕阳和晚霞了。</p>]]></content>
    
    
    <summary type="html">自我总结与展望</summary>
    
    
    
    
    <category term="碎碎念" scheme="https://mrcer.gitee.io/Blog/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>用Termux来开启安卓新姿势</title>
    <link href="https://mrcer.gitee.io/Blog/2022/09/10/Termux/"/>
    <id>https://mrcer.gitee.io/Blog/2022/09/10/Termux/</id>
    <published>2022-09-10T10:48:50.000Z</published>
    <updated>2022-09-10T11:08:38.348Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用Termux来开启安卓新姿势"><a href="#用Termux来开启安卓新姿势" class="headerlink" title="用Termux来开启安卓新姿势"></a>用Termux来开启安卓新姿势</h1><p>Termux是安卓平台上的终端模拟器，用极小的体积提供了Linux环境，适合用来进行轻量的移动学习和开发。</p><p>我接触Termux前还玩过AIDE、qpython等。AIDE确实在开发App上有一定可行性，但收费，而且仅限于开发安卓应用；qpython基本只能跑python，提供的终端也不是很好用。Termux则提供了一个通用的Linux终端环境，可以更自由地学习Linux和各种编程语言。</p><p>然而需要强调的是，Termux原生仅仅提供了最基本的终端环境，不能完全模拟PC环境，而且外设也不适应开发，用手机或平板取代PC开发是很不方便的。因此，Termux更多是给像我一样喜欢折腾的人玩的，实用性并不大。</p><p>如果你准备好了，那就开始享受玩机的乐趣吧~</p><h2 id="准备使用"><a href="#准备使用" class="headerlink" title="准备使用"></a>准备使用</h2><h3 id="安装Termux"><a href="#安装Termux" class="headerlink" title="安装Termux"></a>安装Termux</h3><p>进入<a href="https://termux.dev/en/">Termux官网</a>，你可以看到软件的介绍以及下载地址。<br>软件不要求root环境，但需要安卓7以上版本（当然鸿蒙也可以）。目前github和F-Droid国内都是可以访问的，不过F-Droid可能会更通畅些。</p><h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><p>打开软件，屏幕左侧边缘右滑可以打开终端列表（带手势导航就麻烦了QAQ），而主体内容就是终端界面了，点击即可输入指令。另外Termux还很贴心地附赠了特殊字符输入栏哦OwO</p><p>为了让后续操作更顺畅，接下来需要进行apt换源，如果需要也可以顺便获取储存权限和开启ssh服务。</p><h4 id="apt-换源"><a href="#apt-换源" class="headerlink" title="apt 换源"></a>apt 换源</h4><p>apt是Debian系Linux通用的包管理器，Windows用户可以理解为应用商店。apt使用起来方便快捷，但默认的官网软件源实在缓慢，需要更换到国内镜像源。</p><p>网上很多教程介绍的是Linux通用的方式，通过修改apt配置文件来换源，然而这很繁琐。幸运的是Termux对换源提供了封装，输入<code>termux</code>后按几次<code>Tab</code>键显示可用命令，你就会发现<code>termux-change-repo</code>，输入更多字符（比如<code>termux-c</code>）来明确你想要执行的命令，然后再次<code>Tab</code>完成补全，回车执行后跟着指引走选择中国镜像源组或者单独选tuna清华源均可。确认后应该会自动更新本地软件列表，注意看弹出来的说明，有时是需要输入<code>y</code>来确认操作的。</p><p>另外，上面补全时看到很多<code>termux</code>开头的命令，这些都是Termux提供的工具，可以通过名字猜测或者带<code>--help</code>执行命令查看工具说明（比如<code>termux-change-repo --help</code>）</p><h4 id="获取储存权限"><a href="#获取储存权限" class="headerlink" title="获取储存权限"></a>获取储存权限</h4><p>安卓系统将外存分为系统空间、私密空间和公共空间，系统空间没有root权限不能访问，私密空间仅供应用自己访问，公共空间可供所有申请过权限的应用访问。为了备份数据、向手机其他应用传递数据、访问视频图片等，你可以选择通过执行<code>termux-setup-storage</code>来获取存储权限。</p><h4 id="开启ssh服务"><a href="#开启ssh服务" class="headerlink" title="开启ssh服务"></a>开启ssh服务</h4><p>如果觉得在手机上操作不太方便而且动手能力强，可以尝试开启ssh服务通过电脑连接终端。ssh具体是什么请百度，简单来说就是远程终端，为此你需要：</p><ol><li>安装openssh<br>输入<code>apt install openssh</code>，确认后一般即可完成安装</li><li>设置密码<br>ssh也支持更高级的加密，不过密码是最简单快捷的，输入<code>passwd</code>即可设置用户密码</li><li>启动sshd服务<br>输入<code>sshd</code>即可开启sshd服务，默认端口8022。如无意外终端不会输出任何信息。你可以输入<code>top</code>命令在<code>ARGS</code>列看到sshd的进程（看不到的可以双指缩放或者旋转屏幕），按<code>ctrl+c</code>可以结束命令。想结束服务就关闭软件并杀后台，或者记下<code>top</code>里sshd的pid，用<code>kill pid</code>的方式结束进程。</li><li>连通网络<br>这大概是最难的一步了，需要对计算机网络有一定了解。。你需要让电脑和手机处于同一子网内，还需要避开校园网对低段位端口的封锁。方便起见，你可以用手机开热点，这样电脑连上热点后即处于统一子网内了。接下来要获取手机ip地址。输入<code>ifconfig</code>查看当前网络环境，一般你的手机会连接多个网络，热点应该是p2p开头的，inet后面即手机在热点网络中的ip地址，记下来。</li><li>ssh登陆<br>在电脑终端中输入<code>ssh *ip地址*</code>，确认后输密码即可连接Termux。需要注意的是要保持手机亮屏（调息屏时间）且处于Termux界面，否则可能会被手机杀后台。当然，这很麻烦（也不环保），不过禁用电池优化有很多步骤，比如在设置里打开保持息屏网络连接，在应用中心禁止自动关闭Termux后台等</li></ol><h3 id="安装常用软件"><a href="#安装常用软件" class="headerlink" title="安装常用软件"></a>安装常用软件</h3><p>依次输入以下命令，安装常用软件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~ $ apt install vim         # 安装文本编辑器vim</span><br><span class="line">~ $ apt install python      # 安装Python，至少也是个计算器</span><br><span class="line">~ $ apt install g++         # 你忠实的GNU C++套件，开发C++程序需要</span><br><span class="line">~ $ apt install git         # 版本管理工具git，方便同步工作</span><br></pre></td></tr></table></figure><p>其他软件也可以用类似方式安装，用<code>apt help</code>可以查看更多apt小知识哦~</p><h3 id="图形界面？"><a href="#图形界面？" class="headerlink" title="图形界面？"></a>图形界面？</h3><p>Termux其实也是支持图形界面的，但。。出来的PC桌面对手机太不友好了，图形甚至不支持GPU渲染。如果你想了解可以参考<a href="https://www.jianshu.com/p/195fdb7adc41">这个</a>来配置。</p><h2 id="学习Linux基本操作"><a href="#学习Linux基本操作" class="headerlink" title="学习Linux基本操作"></a>学习Linux基本操作</h2><p>用<code>apt install man</code>安装<code>man</code>，接下来的命令都可以用<code>man 命令</code>的方式查看说明</p><h3 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h3><p>Linux的目录是树状结构的，每个文件夹有两个特别的文件夹：<code>.</code>该文件夹，<code>..</code>上一级文件夹，通过<code>ls</code>命令可以查看当前目录文件（夹）。<code>.</code>开头的文件或文件夹都是隐藏的，可以通过<code>ls -a</code>查看。</p><p>通过<code>cd</code>可以切换文件夹，比如<code>cd ..</code>可以返回上一级文件夹，当前目录路径可以在<code>$</code>前看到，初始是主页<code>~</code>，其上一级是<code>/data/data/com.termux/files</code>，终端指示会隐藏一部分，用<code>pwd</code>可以显示完整路径。</p><p>用<code>ls</code>可以发现当前目录有<code>home</code>和<code>usr</code>，<code>usr</code>就是GUN&#x2F;Linux的相关组件所在目录，可以理解为Windows下的C盘，<code>home</code>则类似于桌面（不过很多软件的配置文件也会以因此文件的形式放在里面），Linux会以<code>~</code>代指。而看到当前完整路径，发现与常规Linux不同，系统文件夹不是根目录<code>\</code>，这是因为Termux并非模拟器，其路径与安卓系统是一致的，Termux能访问的也就只有<code>com.termux</code>下的东西。</p><p>用<code>cd ~</code>回到<code>home</code>，<code>mkdir test</code>即可创建<code>test</code>文件夹；<code>ln</code>命令可以创建文件链接，具体可以百度。</p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p><code>vim a</code>即可打开a文件，如果不存在则vim会创建。vim分为命令模式、输入模式、底线命令模式。初始为命令模式，按<code>i</code>进入输入模式，输入完后按<code>Esc</code>退出，输入<code>:</code>进入底线命令模式，<code>w</code>保存，<code>q</code>退出，<code>:wq</code>一起就是保存退出。更多vim操作可以搜索。</p><p><code>cat a</code>也可以打开文件，但会直接把所有文件内容输出到屏幕。可以用<code>less</code>以<code>cat a | less</code>的形式（管道）让它不会使整个屏幕刷满，回车继续输出，<code>q</code>退出。如果屏幕被刷满了很难看，用<code>clear</code>清空。</p><p><code>mv a b</code>即可把a路径的文件（夹）变成b路径的文件（夹），当然这个也可以用来改名，比如<code>mv ~/cpp/a.cpp ~/b.cpp</code>同时完成了移动和改名</p><p><code>cp a b</code>可以复制文件</p><p><code>zip</code>和<code>unzip</code>可以压缩和解压</p><p><code>rm</code>可以删除文件，加上<code>-r</code>可以删除文件夹，所以 <del>rm -rf &#x2F;</del> 就是删除整个系统（<code>-f</code>是强制的意思，当然实际上会没有权限）。注意Linux没有回收站，谨慎删除。</p><h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><p><code>curl</code>可以“打开”网站（试试<code>curl www.baidu.com</code>），<code>wget</code>可以打开并保存（通常用于下载文件），<code>git clone</code>可以下载项目源代码（去github&#x2F;gitee逛逛？），<code>ls -lh</code>可以显示更详细的信息</p><h2 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h2><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><p>上面已经安装了python，直接输入命令<code>python</code>即可进入交互模式，运行<code>exit()</code>退出。Termux支持<code>pip</code>安装拓展库，但由于平台兼容性问题，如果库依赖本地代码就需要在本地编译构建，很有可能装个几十分钟然后报错退出。目前发现可用的包有<code>sympy</code>（代数系统），<code>pwntools</code>（pwn手工具，部分需编译，要安装十几分钟分钟，现在好像装不上了QAQ），<code>numpy</code>（需要安装cmake并编译几十分钟），<code>jupyterlab</code>，<code>matplotlib</code>，<code>pillow</code>（但需要补全一些运行库，挺麻烦的）。<code>scipy</code>，<code>pandas</code>等由于某些原因装不上。</p><h3 id="C-x2F-C"><a href="#C-x2F-C" class="headerlink" title="C&#x2F;C++"></a>C&#x2F;C++</h3><p>上面已经安装了<code>g++</code>，接下来就可以用<code>vim a.cpp</code>写代码，然后用<code>g++ a.cpp</code>的形式编译源代码（多个文件参与编译就把要编译的文件都在后面加上）。带上<code>-g</code>参数生成调试信息方便debug，<code>-O2</code>开启优化，<code>-o 文件名</code>可以更改输出文件名。编译完成后当前目录会多出一个绿色的可执行文件（默认叫a.out，不要在意后缀，Linux可执行文件后缀不重要），输入<code>./a.out</code>即可执行。这里需要明确程序路径，这是因为Linux终端查找程序的范围不包括当前文件夹。</p><p>用<code>gdb a.exe</code>打开<code>gdb</code>调试器。<code>l</code>可以列出源代码，<code>l a.cpp:0</code>形式可指定文件和行号（多文件编译时有用）；<code>b</code>接数字可以打断点；<code>r</code>运行程序；<code>n</code>跳过语句（多次执行同一条命令不需要重复输入，直接回车即可）；<code>s</code>进入语句；<code>p</code>接表达式打印变量；<code>c</code>继续执行；<code>q</code>退出gdb。</p><h3 id="其他语言"><a href="#其他语言" class="headerlink" title="其他语言"></a>其他语言</h3><p>Termux支持很多语言，包括Java、nodejs、rust、haskell、golang等，安装方式与普通Linux无异</p><h2 id="解锁更多新姿势"><a href="#解锁更多新姿势" class="headerlink" title="解锁更多新姿势"></a>解锁更多新姿势</h2><h3 id="利用Jupyter-Lab在有图形的IDE上开发"><a href="#利用Jupyter-Lab在有图形的IDE上开发" class="headerlink" title="利用Jupyter Lab在有图形的IDE上开发"></a>利用Jupyter Lab在有图形的IDE上开发</h3><p>安装python后，用<code>pip install jupyterlab</code>可以安装jupyter lab，这是一个将python代码和markdown注释结合起来的神器ide，由于其通过Web服务器的形式提供GUI，其使用体验除了不能自动打开浏览器外和普通Linux上无异。不过你要先禁止对Termux的电池优化，否则切出Termux后它很快就被休眠乃至清除了（经测试我手机会在十秒后使其休眠）。另外手机显示PC的界面布局很不好看，面向PC的按键系统对触控也很不友好，如果真的要用，建议配合平板和蓝牙键鼠使用。由于Termux很难调用GPU，python库有些也很难装上，所以Jupyter+Python并不太好用（这方面AidLux会更优秀，但它太重了QAQ）；貌似Jupyter也支持其他语言，我没试过，也许可以。</p><h3 id="利用ffmpeg和Python处理视频图片"><a href="#利用ffmpeg和Python处理视频图片" class="headerlink" title="利用ffmpeg和Python处理视频图片"></a>利用ffmpeg和Python处理视频图片</h3><p>开源软件<code>ffmpeg</code>是很多剪辑软件的内核，其功能强大，可以完成音频视频图片的格式转换、裁切、剪辑、打水印等各种操作，但操作完全命令行，比较难学。<br>Python有pillow库来执行更多图片处理命令，不过因为Termux缺少图形库，这个比较难装。</p><h3 id="口袋里的计算机实验室"><a href="#口袋里的计算机实验室" class="headerlink" title="口袋里的计算机实验室"></a>口袋里的计算机实验室</h3><p>Termux还可以用来进行一些网络安全或计算机组成原理的实验。比如<code>nmap</code>、<code>radara2</code>等软件都是可以使用的</p><h3 id="无限的探索空间"><a href="#无限的探索空间" class="headerlink" title="无限的探索空间"></a>无限的探索空间</h3><p>总之吧，Termux就是给了你接触安卓底层的机会，你终于可以不用被App开发者牵着鼻子走啦！接下来，用Termux搭服务器之类的无限潜力就可以由我们慢慢发掘探索啦！</p>]]></content>
    
    
    <summary type="html">教你用Termux开启安卓终端</summary>
    
    
    
    <category term="折腾实录" scheme="https://mrcer.gitee.io/Blog/categories/%E6%8A%98%E8%85%BE%E5%AE%9E%E5%BD%95/"/>
    
    
    <category term="Linux" scheme="https://mrcer.gitee.io/Blog/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>自学资源分享</title>
    <link href="https://mrcer.gitee.io/Blog/2022/02/08/%E8%87%AA%E5%AD%A6%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/"/>
    <id>https://mrcer.gitee.io/Blog/2022/02/08/%E8%87%AA%E5%AD%A6%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/</id>
    <published>2022-02-08T11:16:38.000Z</published>
    <updated>2022-02-16T15:03:46.478Z</updated>
    
    <content type="html"><![CDATA[<p>这是一则我自学及开发使用的资源的分享，，希望对你有帮助~</p><h1 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h1><h2 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a><a href="https://code.visualstudio.com/">Visual Studio Code</a></h2><p>微软家的全能编辑器，免费开源、好看易用、启动迅速，支持Windows和Linux。需要注意的是VS Code不是一个ide，这意味着它本身是不能编译程序的。然而这也意味着只需要经过简单（大概？）的配置，你就可以用它做任何事情，包括编写任何语言的程序和写博客（对我现在就在用VS Code）。<br><img src="vscode.png" width="50%"/><br>你可以在<a href="https://blog.gztime.cc/posts/2020/6b9b4626/#%E5%89%8D%E8%A8%80">gz的博客</a>那里学会简单的配置。</p><p>VSCode最厉害的地方在于他有一个庞大的拓展库，你可以在里面找到各种东西。比如说你看到上面的插图中有一只魔理沙，那个是background插件，其他的还有各种语言配套的语言插件啦，用AI来完成自动补全的Tabnice插件啦，二进制文件查看的hexdump啦，写博客用markdown语言有Markdown All in One插件啦。总之有了VSCode，其他编辑器我都再也没用啦！</p><h2 id="Visual-Studio"><a href="#Visual-Studio" class="headerlink" title="Visual Studio"></a><a href="https://visualstudio.microsoft.com/zh-hans/">Visual Studio</a></h2><p>Visual Studio是微软家的IDE，可以开发.NET、C++等等。与VSCode不同的是，VS是以项目为单位来开发的，而VSCode一般以文件为单位编译运行，同时VS本身就包含了IDE应有的编译、调试、打包等功能。然而，这些功能的代价是庞大的安装体积和较慢的启动速度。</p><p>一般我小的项目我都会用VSCode，只有项目太大，需要链接库之类的时候我才会用VSCode，比如学习OpenGL。</p><p>既然说到IDE我顺便把其他的也说了吧，毕竟那些都是在开发相应程序的时候才需要了解的，就不单独说啦。比如开发Java可以用<a href="https://www.jetbrains.com/idea/">Intellij idea</a>（只在开发MC模组的时候用），开发Python可以用<a href="https://www.jetbrains.com/pycharm/">PyCharm</a>（没用过），开发安卓应用可以用<a href="https://developer.android.google.cn/studio/">Android Studio</a>（没咋用过，倒是AIDE用过）等等。</p><h2 id="菜鸟教程"><a href="#菜鸟教程" class="headerlink" title="菜鸟教程"></a><a href="https://www.runoob.com/">菜鸟教程</a></h2><p>我首选的学习语言的网站。这个网站优点就在于主要的语言乃至一些技术都有教程，而且还是中文！不仅如此，网站内容意简言赅，没有半句废话，特别适合有经验的人学习新语言。然而这个网站部分内容存在过时（比如Python教程就是2&#x2F;3混在一起的），有些内容因为精简也省略了，还有大部分库都没有详细的介绍。如果你需要了解一门语言的具体技术细节的话不妨参考文档，比如<a href="https://www.cplusplus.com/reference/">c++ reference</a>，<a href="https://www.python.org/doc/">Python文档</a>等等。不过你要做好啃生肉的准备。</p><h2 id="bilibili"><a href="#bilibili" class="headerlink" title="bilibili"></a><a href="https://www.bilibili.com/">bilibili</a></h2><p>是的，B站大学实至名归，从编程到电焊，从医学到数学，你能找到各种学习内容，这里简单分享几个：</p><ol><li>3Blue1Brown：分享数学知识的up主，我线代96分，一半是他教的。不下饭，要经常暂停。</li><li>硬件茶谈：分享硬核硬件常识的up主，看完你就能自己装电脑了。</li><li>稚晖君：告诉你学霸可以做到什么地步</li><li>LinusTechTips：老莱的计算机科普，教你各种计算机相关的冷知识</li><li>极客湾Geekerwan：硬件评测，是个折腾的up主，让你能紧跟时代潮流，看懂最新硬件。</li><li>BranchEducation：一个介绍计算机原理的新up，看起来可视化有点东西，可以了解一下</li><li>Chubbyemu：分享临床医学案例的up主，很下饭，还能教你基本的医学常识</li><li>学院派Academia：分享社科知识的up主，非常硬核，下饭催眠都很好用</li><li>罗翔说刑法：教法律知识的，下饭，也能培养三观</li><li>人民医学：简单的医学科普</li><li>爱上半导体：电子信息专业的可以看看，讲半导体相关的，可视化做得不错</li><li>六层楼先生：妇产科医生，性科普做得不错</li><li>阿林吃土：教做饭的，小白入门级</li></ol><p>还有一些泛科普的、教音乐美术的、教建模的、教特效剪辑的、教游戏理论的、教物理化学的、教历史的、甚至教昆虫的、教你学习的。想了解的可以关注我B站号：深海菠萝小狮子。</p><p>值得一提的是，B站的科普是面向所有人的，优点是可视化程度高，以视频形式展现容易看懂，但缺点也很明显：</p><ol><li>很少有系统讲解知识的，大部分都是简化过的知识，只可以当做初步了解。</li><li>科普up的知识也是有限的，也许会有错误内容，甚至有的up会夹带私货，观看时要时刻保持辩证思维。</li><li>up主为了恰饭有时需要打广告。</li></ol><p>如果你真的想系统学习某种知识，你最好找那种分十几p的视频，或者直接去中国大学mooc学。</p><h2 id="Termux"><a href="#Termux" class="headerlink" title="Termux"></a><a href="https://termux.com/">Termux</a></h2><p>一个运行在安卓上的Linux终端。使用这个软件你可以在手机上写程序、跑代码、连接服务器、学习Linux、装逼等等。终端，也就是说没有图形界面，同时自带的Linux系统也是非常简洁的（软件包才97M），你需要安装许多软件，非常折腾。如果你不想折腾，<a href="https://www.aidlux.com/">AidLearning</a>可能也不错，预装了完整的系统和各种软件，不过占用空间非常大，也比较卡，让本来就不太实用的东西更不实用了哈哈哈（当然主要是软件不会用）。</p><p>这里简单说一下这个软件怎么用吧，以后还会写折腾笔记的。</p><p>你首先得先学会Linux的基本操作，这个菜鸟教程有，包括目录操作命令、新建复制粘贴软件安装命令（软件自带pkg作为包管理器，apt也行）。然后安装vim作为文本编辑器，需要开发C++的话装g++，需要运行python就装python之类的。你还能用nmap扫端口（不过官网说软件库不提供黑客工具，你得自己整），ping服务器，查看网络设置等等。</p><p>当然如果你只是想学Linux的话还有很多选择，最简单的就是WSL，也可以像我以前大佬那样塞个系统进U盘，也不是不行。</p><h2 id="Jupyter"><a href="#Jupyter" class="headerlink" title="Jupyter"></a>Jupyter</h2><p>你想学习Python的库吗？快用Jupyter！这种全新的交互方式将markdown和python结合在一起，让你的学习笔记能跑代码。来，直接上图！<br><img src="Jupyter.png" width="80%"/></p><p>这个博客是零基础的，这里简单介绍一下markdown和python。</p><p>Markdown是一个轻量级的标记语言，你可以理解为超简单的word。首先，用MD你就不需要鼠标了，标题直接用<code>#</code>，多少级标题就用多少个<code>#</code>，你不需要调字体大小；加粗斜体都用<code>*</code>；还有插入链接、代码框、注释等都是非常方便的。插入数学公式、插入图片、插入表格当然也能做到，不过有点小麻烦，可以用一些对应的工具来简化。MD本身是个纯文本文件，需要渲染器才能显示效果，你可以理解为源文件和编译。btw，这篇博客基本上就是用Markdown写的。<br><img src="md.png" width="80%"/></p><p>Python是一个简单的脚本语言，但是很多东西都能干。当然，这样强大的功能是依赖库的，比如你学会Sympy就能完成很多平常要在Matlab完成的操作，学会Pillow就可以用代码处理图片，还有人工智能很多都是有Python接口的。</p><p>安装也很简单，先装个python，然后命令行跑个<code>pip install jupyterlab</code>安装jupyter和更好看的前端界面，完成。接下来命令行运行<code>jupyter lab</code>你就启动了jupyter服务器了，读一下命令行的文字，用浏览器打开那个网址，你就进入到jupyter了。如果你想用更接近你平常用软件的方式工作的话，VSCode有Jupyter插件，你装好python和jupyter之后再打开VSCode装Jupyter插件就可以像打开一个普通文件一样打开<code>.ipynb</code>的notebook文件了。</p><h2 id="一些其他的网站"><a href="#一些其他的网站" class="headerlink" title="一些其他的网站"></a>一些其他的网站</h2><ol><li><a href="https://www.kaggle.com/">kaggle</a>：一个学习机器学习的网站</li><li><a href="https://leetcode-cn.com/">leetcode</a>：刷题网站，不多说</li><li><a href="https://ctf-wiki.org/">ctf-wiki</a>：学习CTF技能的</li><li><a href="https://oi-wiki.org/">oi-wiki</a>：学算法的</li></ol><p>（未完待续，咕咕咕）</p>]]></content>
    
    
    <summary type="html">这是一则我自学及开发使用的资源的分享，希望对你有帮助~</summary>
    
    
    
    
    <category term="资源分享" scheme="https://mrcer.gitee.io/Blog/tags/%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
</feed>
