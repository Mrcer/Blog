<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>深海里的大菠萝</title>
  
  
  <link href="https://mrcer.gitee.io/Blog/atom.xml" rel="self"/>
  
  <link href="https://mrcer.gitee.io/Blog/"/>
  <updated>2024-11-06T05:56:07.096Z</updated>
  <id>https://mrcer.gitee.io/Blog/</id>
  
  <author>
    <name>大菠萝</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CMake 前置知识 - 在你学习 CMake 之前</title>
    <link href="https://mrcer.gitee.io/Blog/2024/11/06/CMake-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86-%E5%9C%A8%E4%BD%A0%E5%AD%A6%E4%B9%A0-CMake-%E4%B9%8B%E5%89%8D/"/>
    <id>https://mrcer.gitee.io/Blog/2024/11/06/CMake-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86-%E5%9C%A8%E4%BD%A0%E5%AD%A6%E4%B9%A0-CMake-%E4%B9%8B%E5%89%8D/</id>
    <published>2024-11-06T02:03:44.000Z</published>
    <updated>2024-11-06T05:56:07.096Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CMake-前置知识-在你学习-CMake-之前"><a href="#CMake-前置知识-在你学习-CMake-之前" class="headerlink" title="CMake 前置知识 - 在你学习 CMake 之前"></a>CMake 前置知识 - 在你学习 CMake 之前</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章不是用来介绍 CMake 的使用方式的，作者也并没有深入了解过 CMake，甚至没有自己写过独立项目。写下这篇文章只是为了指引像一两年前我的人：</p><ol><li>刚刚走出 devc++，初次接触命令行、多文件编译</li><li>第一次部署 C++ 项目，看到复杂的项目构造和不熟悉的构建过程而不知所措</li><li>热切地希望通过学习 CMake 来掌握项目开发能力</li></ol><p>那时候的我像渴望飞翔的雏鹰，看到大家都用 CMake 自己也想学，希望能提高自己的能力。然而询问学长得到的答案基本都是 “这种东西用到再查就行了”、“CMake 不用学习，会用就行”，自己查则很多都看不懂，用起来也遇到很多配置错误很难完成部署。</p><p>如果我能回去指导那时候的我，我希望能有这样一篇文章，铺平从 devc++ 到 CMake 的路，或者至少给出一张更加清晰的地图，告诉我不要着急，迷雾会在未来扫清。</p><h2 id="C-编译过程简述"><a href="#C-编译过程简述" class="headerlink" title="C++ 编译过程简述"></a>C++ 编译过程简述</h2><p>这部分知识会在 <em>编译原理</em> 课程中系统介绍，也可以通过阅读 CSAPP 自学，B站 up 主 <em>九曲阑干</em> 将该书制作成视频，可以借此快速入门。这里我会简单过一遍。</p><p>在 IDE 如 devc++ 中，我们写下 <code>hello.cpp</code> 源文件后，需要先对它进行编译生成 <code>hello.exe</code> 文件后才能运行。但事实上从高级语言到机器语言的 <em>编译</em> 操作并非一步到位的，而是至少包含预处理、编译、汇编和链接四个步骤。</p><p>预处理阶段负责对输入的源文件标准化。C++ 对程序的写法是比较宽松的，你可以在各种地方加入任意空格，可以反斜杠换行，还可以用诸如 <code>#define MAX((A),(B)) ...</code> 这类宏指令，他们都需要被预编译器修剪、展开，以方便编译阶段处理。 </p><p>编译阶段会将预处理过的源代码一步步解释成程序执行流，并在这过程中进行优化和信息提取，最终生成汇编代码。这部分对应编译原理的词法分析、语法分析、语义分析、中间代码生成等等内容，因此不会在此展开。你只需要知道最后生成的汇编代码依然是人类可读的，只是不再包含层次结构，每一条语句也只会执行最基础的操作即可。</p><p>汇编阶段会将编译出的汇编文件转换成目标文件，这是一种人类不可读的二进制代码，你可以理解为可执行文件的一部分。注意到这里为止都是对单个源代码文件来说的，也就是 <code>hello.cpp</code> 预处理为 <code>hello.i</code>，编译为 <code>hello.s</code>，汇编为 <code>hello.o</code>。</p><p>链接阶段会将可执行文件的不同部分组合起来，输出最终的可执行文件。不同的部分可能包括自己写的多个源代码目标文件（比如这里的 <code>hello.cpp</code> 、标准库文件（比如包含 <code>iostream</code> 的动态链接库）、用户库文件，它们会以或静态或动态的方式组合在一起。这一步骤经常发生错误，但对平常只写单文件的开发者又很陌生，遇到时往往会不知所措。所以以后当你遇到以 <code>链接失败</code> 之类开头的错误，或者错误信息是“找不到函数”“变量名重复”之类的，你就知道是怎么回事了。</p><p>以上这些编译过程一般都会由编译器（如gcc、clang、msvc）按默认流程一步执行到位，我们也可以选择性地执行到某个位置，而这正是 <code>构建</code> 的基础。</p><h2 id="什么是构建工具"><a href="#什么是构建工具" class="headerlink" title="什么是构建工具"></a>什么是构建工具</h2><p>构建就是将项目编译打包成可执行文件的过程，而构建工具源于以下需求：</p><ol><li>文件很多，手动编译费时费力</li><li>如果单纯写一个脚本全部编译一遍，那没修改过的源文件就会被重复编译，很浪费时间</li><li>希望简化编译脚本，方便地提供配置、编译、测试、清理、安装等功能</li></ol><p>可见，如果我们只有一个源文件，大可以直接调用编译器生成可执行文件，后面的 make 和 cmake 啥的就没有必要了。</p><p>但很多软件是有以上需求的，于是 Makefile、ninja 等工具应运而生。他们会识别没编译过的或被修改过的源代码，将他们编译为目标文件，再链接起来。以 Makefile 为例，我们加入另一个源文件 <code>some_func.cpp</code>，然后写一个简单的编译脚本：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">hello.exe: hello.o some_func.o</span></span><br><span class="line">    g++ hello.o some_func.o -o hello.exe</span><br><span class="line"></span><br><span class="line"><span class="section">hello.o: hello.cpp</span></span><br><span class="line">    g++ -c hello.cpp -o hello.o</span><br><span class="line"></span><br><span class="line"><span class="section">some_func.o: some_func.cpp</span></span><br><span class="line">    g++ -c some_func.cpp -o some_func.o</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    del hello.exe</span><br><span class="line">    del hello.o</span><br><span class="line">    del some_func.o</span><br></pre></td></tr></table></figure><p>将这个脚本和源文件一起保存在同一目录，命名为 <code>makefile</code>，即可用 make 完成构建。</p><p>可以看到 <code>makefile</code> 的格式很简单，就是一组组的文件生成规则列下来，每个文件都可能依赖其他文件，会标注在冒号后面，然后下面用 <code>Tab</code> 缩进接生成文件所需要的命令。写好之后运行 make 程序，他就会默认生成第一个文件，根据依赖递归地执行命令。make 会根据文件的修改时间判断哪些是不需要重新生成的，从而减少构建时间。</p><h2 id="为什么需要-CMake"><a href="#为什么需要-CMake" class="headerlink" title="为什么需要 CMake"></a>为什么需要 CMake</h2><p>初步使用过 CMake 后就会发现，CMake 其实是用来生成 Makefile 等构建配置文件的工具，那为什么有了构建工具还需要 CMake 这样套娃呢？据我了解有以下原因：</p><ol><li>跨构建工具：构建工具有很多种，比如 makefile、ninja、msbuild等等，我们希望用一个统一的配置文件生成不同构建工具的配置</li><li>跨编译器：编译器也有很多种，比如 gcc、clang、msvc等等，我们希望用一个配置文件方便地生成使用不同编译器的构建文件</li><li>依赖管理：大型软件一般会产生诸多依赖库（不是文件依赖），而编写构建过程的人并不清楚开发者将依赖放在哪里，所以需要有一个系统找到各种依赖来完成编译链接过程</li><li>灵活配置：构建工具是以文件作为生成任务的，但有时我们需要更复杂的配置，比如区分 Debug、Release 的程序，比如允许让程序选择性地包含某些功能模块等等</li></ol><p>总的来说，cmake 让构建过程实现了跨平台、自动化、灵活配置。如果你不需要这些功能，而仅仅是包含多个文件、运行在本地、没有什么依赖的个人项目，使用构建工具就已经足够了。 </p><p>如果你已经做好准备，要开创一个大事业，那就准备好使用 CMake 吧。</p><p>P.S. CMake 的依赖管理好像只负责找到依赖，而不具备包管理器应有的下载、安装、罗列、卸载等操作，你需要其他如 conan 的工具来做到这一点。。所以说 rust 的 cargo 真是一个很先进的工具。</p><h2 id="接下来要学习什么"><a href="#接下来要学习什么" class="headerlink" title="接下来要学习什么"></a>接下来要学习什么</h2><p>看完这一切后，如果你决定使用 CMake，你只需要知道下面知识就行：</p><ol><li>一般先创建 build 文件夹来存放构建产生的文件，在此目录下运行构建指令。如果你忘了，你会发现仓库根目录下一片狼藉。。</li><li>确保一切工具准备到位，包括编译工具（推荐 clang）、构建工具（推荐 ninja）、CMake，并且配好了环境变量</li><li>在 build 目录下运行 <code>cmake ..</code>，其中 <code>..</code> 是包含 <code>CMakeLists.txt</code> 的目录。CMake 会尝试寻找合适的工具链并生成构建配置，第一次操作请检查工具链选择是否符合你的想法，因为 CMake 可能会找不到工具链或选择了错误的工具链。</li><li>运行 <code>cmake --build .</code> 完成构建。CMake 会根据配置调用构建工具完成构建</li></ol><p>如果你还想编写 CMake 文件，我可能提供不了太多帮助，可以参考下面的内容：</p><ol><li>快速入门：<a href="https://www.runoob.com/cmake/cmake-tutorial.html">CMake 教程 | 菜鸟教程</a></li><li>一些书（中文，现搜的，算是mark一下）：<ol><li><a href="https://modern-cmake-cn.github.io/Modern-CMake-zh_CN/">Modern CMake 简体中文版</a></li><li><a href="https://www.bookstack.cn/read/CMake-Cookbook/README.md">CMake Cookbook</a></li></ol></li><li>官方教程（要求英文阅读）：<a href="https://cmake.org/cmake/help/book/mastering-cmake/cmake/Help/guide/tutorial/index.html#">官方教程</a></li></ol><p>另外，请确保你已经学习过 <em>软件工程</em>，这能解答很多为什么这样设计的困惑。</p>]]></content>
    
    
    <summary type="html">如果我能回去指导那时候的我，我希望能有这样一篇文章，铺平从 devc++ 到 CMake 的路，或者至少给出一张更加清晰的地图，告诉我不要着急，迷雾会在未来扫清。</summary>
    
    
    
    
    <category term="技术杂谈" scheme="https://mrcer.gitee.io/Blog/tags/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>从离奇bug到C++未定义行为</title>
    <link href="https://mrcer.gitee.io/Blog/2024/03/31/%E4%BB%8E%E7%A6%BB%E5%A5%87bug%E5%88%B0C-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA/"/>
    <id>https://mrcer.gitee.io/Blog/2024/03/31/%E4%BB%8E%E7%A6%BB%E5%A5%87bug%E5%88%B0C-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA/</id>
    <published>2024-03-31T13:55:28.000Z</published>
    <updated>2024-03-31T15:26:35.544Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从离奇bug到C-未定义行为"><a href="#从离奇bug到C-未定义行为" class="headerlink" title="从离奇bug到C++未定义行为"></a>从离奇bug到C++未定义行为</h1><p>这是发生于2022年12月18日凌晨的事情，起因也许是数据结构课的某道算法题吧，遇到了非常离奇的bug，最后在群友们专家会诊两小时后找到了原因。现在我用聊天记录尽可能还原当时场景。</p><h2 id="开端"><a href="#开端" class="headerlink" title="开端"></a>开端</h2><p>这是一条很普通的算法题，大概是用先序遍历和中序遍历还原二叉树。下面是我写的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">    <span class="type">int</span> l;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Node&gt; tree;</span><br><span class="line">string sa, sb;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> al, <span class="type">int</span> ar, <span class="type">int</span> bl, <span class="type">int</span> br)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> index = tree.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> bpos = bl;</span><br><span class="line">    <span class="keyword">while</span>(sb[bpos] != sa[al]) bpos++;</span><br><span class="line">    <span class="type">int</span> llen=bpos-bl, rlen=br-bpos;</span><br><span class="line">    Node n;</span><br><span class="line">    n.c = sa[al];</span><br><span class="line">    n.w = llen == <span class="number">0</span> &amp;&amp; rlen == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    tree.<span class="built_in">push_back</span>(n);</span><br><span class="line">    <span class="keyword">if</span>(llen != <span class="number">0</span>) &#123;</span><br><span class="line">        tree[index].l = <span class="built_in">build</span>(al<span class="number">+1</span>, al+llen, bl, bl+llen<span class="number">-1</span>);</span><br><span class="line">        tree[index].w += tree[tree[index].l].w;</span><br><span class="line">    &#125; <span class="keyword">else</span> tree[index].l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(rlen != <span class="number">0</span>) &#123;</span><br><span class="line">        tree[index].r = <span class="built_in">build</span>(al+llen<span class="number">+1</span>, ar, bl+llen<span class="number">+1</span>, br);</span><br><span class="line">        tree[index].w += tree[tree[index].r].w;</span><br><span class="line">    &#125; <span class="keyword">else</span> tree[index].r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; tree[n].w ; i++) cout &lt;&lt; tree[n].c;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span>(tree[n].l != <span class="number">0</span>) <span class="built_in">print</span>(tree[n].l);</span><br><span class="line">    <span class="keyword">if</span>(tree[n].r != <span class="number">0</span>) <span class="built_in">print</span>(tree[n].r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; sa &gt;&gt; sb;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">0</span>, sa.<span class="built_in">size</span>()<span class="number">-1</span>, <span class="number">0</span>, sb.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来很普通，然而我发现哪怕是输入<code>AB AB</code>，程序都会发生段错误，诡异的是……</p><img src="gdb1.png"/><p>可以看到在第 29 行代码处，<code>tree[index].r</code>被<code>build</code>赋的值竟然是非法的，而前面按步执行明明是合法的！</p><p>“更玄学的是，如果开个临时变量保存返回值再赋值回去，就没事了”</p><p>群友们陆续出动，纷纷在自己的电脑上跑了一下代码，有的段错误，有的却正常运行……</p><p>难道，是编译器有bug？</p><h2 id="会诊"><a href="#会诊" class="headerlink" title="会诊"></a>会诊</h2><p>虽然从聊天记录里看不出来，但其实作为有点内向的我，发问前一定已经做了充分的研究。我已经大概猜到要到汇编层面才能寻找到答案，然而苦于没有合适工具</p><p>radare坏了，ida不会用，静态分析看不懂，真的很菜（）</p><p>群友Fox用clang挂ASAN没有扫到内存错误，建议继续挂调试器找内存错误原因<br>群友GZ复现了错误，正在配置调试环境<br>群友c猜测是逻辑错误<br>群友jy查看后台，初露端倪：</p><p>“草，确实有可能是 gcc 的问题，刚刚看了下：<br>他 wsl 是 gcc 9<br>测评是 gcc 10<br>我 ubt 22.04 是 gcc 11<br>我 mingw 是 gcc 12”</p><p>我发问前应该已经调试了一下午了，都已经爬上床准备睡了，看到群友们干劲十足，自己也不好意思干等着，麻溜地爬下床测试程序复现bug，真的好冷QAQ。</p><p>Fox不相信是 gcc 的问题，而GZ沿着这条线索开始深入汇编寻找真相……</p><p>如此玄学的bug，我不禁想起前不久B站某次<a href="https://www.bilibili.com/read/cv17521097/">夜间大规模崩溃报告</a>，最终原因竟然是一小段lua代码，在某种情况下以错误的参数调用了 _gcd 函数，导致死循环。</p><h2 id="揭示"><a href="#揭示" class="headerlink" title="揭示"></a>揭示</h2><p>随着群友们深入汇编，答案即刻浮现。</p><p>Fox使用 <a href="https://godbolt.org/">Compiler Explorer</a> 为我们揭示了答案：</p><img src="1711896716714.png"/><img src="1711896737238.png"/><p>可以看到，g++10 和 g++12 在 <code>tree[index].r = build(al+llen+1, ar, bl+llen+1, br);</code> 处编译结果并不相同。</p><p>汇编也许有点难度，但只看红色部分，我们不难发现有两个操作的顺序是反的！也就是 <code>build(int, int, int, int)</code> 和 <code>std::vector&lt;Node, std::allocator&lt;Node&gt; &gt;::operator[](unsigned long)</code></p><p>前面这个好理解，就是赋值前函数运算，后面这个是……</p><p>对喔！tree 是一个 vector ，那么它的下标运算符当然是运算符重载函数，这样一来段错误的原因就很明显了！</p><p>在编译器眼里这条语句就相当于 <code>f() = g()</code>，因为 C++ 标准并未规定相同优先级的函数谁先执行，从左到右执行应当是很合理的。<br>然而在这里，这样就相当于先执行下标引用再执行<code>build</code>。<br>一般而言，这不会带来什么问题，但在这里，<code>build</code>是一个递归函数，<code>tree</code>完全有可能会在<code>build</code>执行过程中被插入数据，导致容器大小改变。<br>而<code>vector</code>大小一旦超过预分配的内存，就会触发扩容，如此一来先前调用下标引用得到的地址就会无效！</p><p>未定义行为！是未定义行为！</p><h2 id="散会"><a href="#散会" class="headerlink" title="散会"></a>散会</h2><p>后来我们好像查到，是有人反馈过这个问题，g++在后来就“修复”了这个bug</p><p>然而从原理上讲，好像又不能怪罪g++，毕竟确实是未定义行为。</p><p>如果要总结什么教训的话，或许就是应该意识到，在享受C++运算符重载便利的同时，也应当注意到它终究是个函数，可能会带来意想不到的情形吧。<br>好像还有点关于副作用函数的关联，但因为不太了解，就按下不表了。<br>总之，将容器解引用放在等号左边前请三思。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这篇文章是靠事后回忆写成的，我的印象也很模糊了，但揭示真相时还是很震撼。</p><p>前面的铺垫可能太短了，毕竟我文笔不好也没记不清，但我得说，参与讨论的几位群友直到现在我都觉得是很厉害的大佬，他们围绕这个问题在新年前深夜足足讨论了两小时！</p><p>希望能给你带来新的思考~</p>]]></content>
    
    
    <summary type="html">一直答应要写的博客终于在今天开始写啦！</summary>
    
    
    
    
    <category term="技术杂谈" scheme="https://mrcer.gitee.io/Blog/tags/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>用Termux来开启安卓新姿势</title>
    <link href="https://mrcer.gitee.io/Blog/2022/09/10/Termux/"/>
    <id>https://mrcer.gitee.io/Blog/2022/09/10/Termux/</id>
    <published>2022-09-10T10:48:50.000Z</published>
    <updated>2022-09-10T11:08:38.348Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用Termux来开启安卓新姿势"><a href="#用Termux来开启安卓新姿势" class="headerlink" title="用Termux来开启安卓新姿势"></a>用Termux来开启安卓新姿势</h1><p>Termux是安卓平台上的终端模拟器，用极小的体积提供了Linux环境，适合用来进行轻量的移动学习和开发。</p><p>我接触Termux前还玩过AIDE、qpython等。AIDE确实在开发App上有一定可行性，但收费，而且仅限于开发安卓应用；qpython基本只能跑python，提供的终端也不是很好用。Termux则提供了一个通用的Linux终端环境，可以更自由地学习Linux和各种编程语言。</p><p>然而需要强调的是，Termux原生仅仅提供了最基本的终端环境，不能完全模拟PC环境，而且外设也不适应开发，用手机或平板取代PC开发是很不方便的。因此，Termux更多是给像我一样喜欢折腾的人玩的，实用性并不大。</p><p>如果你准备好了，那就开始享受玩机的乐趣吧~</p><h2 id="准备使用"><a href="#准备使用" class="headerlink" title="准备使用"></a>准备使用</h2><h3 id="安装Termux"><a href="#安装Termux" class="headerlink" title="安装Termux"></a>安装Termux</h3><p>进入<a href="https://termux.dev/en/">Termux官网</a>，你可以看到软件的介绍以及下载地址。<br>软件不要求root环境，但需要安卓7以上版本（当然鸿蒙也可以）。目前github和F-Droid国内都是可以访问的，不过F-Droid可能会更通畅些。</p><h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><p>打开软件，屏幕左侧边缘右滑可以打开终端列表（带手势导航就麻烦了QAQ），而主体内容就是终端界面了，点击即可输入指令。另外Termux还很贴心地附赠了特殊字符输入栏哦OwO</p><p>为了让后续操作更顺畅，接下来需要进行apt换源，如果需要也可以顺便获取储存权限和开启ssh服务。</p><h4 id="apt-换源"><a href="#apt-换源" class="headerlink" title="apt 换源"></a>apt 换源</h4><p>apt是Debian系Linux通用的包管理器，Windows用户可以理解为应用商店。apt使用起来方便快捷，但默认的官网软件源实在缓慢，需要更换到国内镜像源。</p><p>网上很多教程介绍的是Linux通用的方式，通过修改apt配置文件来换源，然而这很繁琐。幸运的是Termux对换源提供了封装，输入<code>termux</code>后按几次<code>Tab</code>键显示可用命令，你就会发现<code>termux-change-repo</code>，输入更多字符（比如<code>termux-c</code>）来明确你想要执行的命令，然后再次<code>Tab</code>完成补全，回车执行后跟着指引走选择中国镜像源组或者单独选tuna清华源均可。确认后应该会自动更新本地软件列表，注意看弹出来的说明，有时是需要输入<code>y</code>来确认操作的。</p><p>另外，上面补全时看到很多<code>termux</code>开头的命令，这些都是Termux提供的工具，可以通过名字猜测或者带<code>--help</code>执行命令查看工具说明（比如<code>termux-change-repo --help</code>）</p><h4 id="获取储存权限"><a href="#获取储存权限" class="headerlink" title="获取储存权限"></a>获取储存权限</h4><p>安卓系统将外存分为系统空间、私密空间和公共空间，系统空间没有root权限不能访问，私密空间仅供应用自己访问，公共空间可供所有申请过权限的应用访问。为了备份数据、向手机其他应用传递数据、访问视频图片等，你可以选择通过执行<code>termux-setup-storage</code>来获取存储权限。</p><h4 id="开启ssh服务"><a href="#开启ssh服务" class="headerlink" title="开启ssh服务"></a>开启ssh服务</h4><p>如果觉得在手机上操作不太方便而且动手能力强，可以尝试开启ssh服务通过电脑连接终端。ssh具体是什么请百度，简单来说就是远程终端，为此你需要：</p><ol><li>安装openssh<br>输入<code>apt install openssh</code>，确认后一般即可完成安装</li><li>设置密码<br>ssh也支持更高级的加密，不过密码是最简单快捷的，输入<code>passwd</code>即可设置用户密码</li><li>启动sshd服务<br>输入<code>sshd</code>即可开启sshd服务，默认端口8022。如无意外终端不会输出任何信息。你可以输入<code>top</code>命令在<code>ARGS</code>列看到sshd的进程（看不到的可以双指缩放或者旋转屏幕），按<code>ctrl+c</code>可以结束命令。想结束服务就关闭软件并杀后台，或者记下<code>top</code>里sshd的pid，用<code>kill pid</code>的方式结束进程。</li><li>连通网络<br>这大概是最难的一步了，需要对计算机网络有一定了解。。你需要让电脑和手机处于同一子网内，还需要避开校园网对低段位端口的封锁。方便起见，你可以用手机开热点，这样电脑连上热点后即处于统一子网内了。接下来要获取手机ip地址。输入<code>ifconfig</code>查看当前网络环境，一般你的手机会连接多个网络，热点应该是p2p开头的，inet后面即手机在热点网络中的ip地址，记下来。</li><li>ssh登陆<br>在电脑终端中输入<code>ssh *ip地址*</code>，确认后输密码即可连接Termux。需要注意的是要保持手机亮屏（调息屏时间）且处于Termux界面，否则可能会被手机杀后台。当然，这很麻烦（也不环保），不过禁用电池优化有很多步骤，比如在设置里打开保持息屏网络连接，在应用中心禁止自动关闭Termux后台等</li></ol><h3 id="安装常用软件"><a href="#安装常用软件" class="headerlink" title="安装常用软件"></a>安装常用软件</h3><p>依次输入以下命令，安装常用软件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~ $ apt install vim         # 安装文本编辑器vim</span><br><span class="line">~ $ apt install python      # 安装Python，至少也是个计算器</span><br><span class="line">~ $ apt install g++         # 你忠实的GNU C++套件，开发C++程序需要</span><br><span class="line">~ $ apt install git         # 版本管理工具git，方便同步工作</span><br></pre></td></tr></table></figure><p>其他软件也可以用类似方式安装，用<code>apt help</code>可以查看更多apt小知识哦~</p><h3 id="图形界面？"><a href="#图形界面？" class="headerlink" title="图形界面？"></a>图形界面？</h3><p>Termux其实也是支持图形界面的，但。。出来的PC桌面对手机太不友好了，图形甚至不支持GPU渲染。如果你想了解可以参考<a href="https://www.jianshu.com/p/195fdb7adc41">这个</a>来配置。</p><h2 id="学习Linux基本操作"><a href="#学习Linux基本操作" class="headerlink" title="学习Linux基本操作"></a>学习Linux基本操作</h2><p>用<code>apt install man</code>安装<code>man</code>，接下来的命令都可以用<code>man 命令</code>的方式查看说明</p><h3 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h3><p>Linux的目录是树状结构的，每个文件夹有两个特别的文件夹：<code>.</code>该文件夹，<code>..</code>上一级文件夹，通过<code>ls</code>命令可以查看当前目录文件（夹）。<code>.</code>开头的文件或文件夹都是隐藏的，可以通过<code>ls -a</code>查看。</p><p>通过<code>cd</code>可以切换文件夹，比如<code>cd ..</code>可以返回上一级文件夹，当前目录路径可以在<code>$</code>前看到，初始是主页<code>~</code>，其上一级是<code>/data/data/com.termux/files</code>，终端指示会隐藏一部分，用<code>pwd</code>可以显示完整路径。</p><p>用<code>ls</code>可以发现当前目录有<code>home</code>和<code>usr</code>，<code>usr</code>就是GUN&#x2F;Linux的相关组件所在目录，可以理解为Windows下的C盘，<code>home</code>则类似于桌面（不过很多软件的配置文件也会以因此文件的形式放在里面），Linux会以<code>~</code>代指。而看到当前完整路径，发现与常规Linux不同，系统文件夹不是根目录<code>\</code>，这是因为Termux并非模拟器，其路径与安卓系统是一致的，Termux能访问的也就只有<code>com.termux</code>下的东西。</p><p>用<code>cd ~</code>回到<code>home</code>，<code>mkdir test</code>即可创建<code>test</code>文件夹；<code>ln</code>命令可以创建文件链接，具体可以百度。</p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p><code>vim a</code>即可打开a文件，如果不存在则vim会创建。vim分为命令模式、输入模式、底线命令模式。初始为命令模式，按<code>i</code>进入输入模式，输入完后按<code>Esc</code>退出，输入<code>:</code>进入底线命令模式，<code>w</code>保存，<code>q</code>退出，<code>:wq</code>一起就是保存退出。更多vim操作可以搜索。</p><p><code>cat a</code>也可以打开文件，但会直接把所有文件内容输出到屏幕。可以用<code>less</code>以<code>cat a | less</code>的形式（管道）让它不会使整个屏幕刷满，回车继续输出，<code>q</code>退出。如果屏幕被刷满了很难看，用<code>clear</code>清空。</p><p><code>mv a b</code>即可把a路径的文件（夹）变成b路径的文件（夹），当然这个也可以用来改名，比如<code>mv ~/cpp/a.cpp ~/b.cpp</code>同时完成了移动和改名</p><p><code>cp a b</code>可以复制文件</p><p><code>zip</code>和<code>unzip</code>可以压缩和解压</p><p><code>rm</code>可以删除文件，加上<code>-r</code>可以删除文件夹，所以 <del>rm -rf &#x2F;</del> 就是删除整个系统（<code>-f</code>是强制的意思，当然实际上会没有权限）。注意Linux没有回收站，谨慎删除。</p><h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><p><code>curl</code>可以“打开”网站（试试<code>curl www.baidu.com</code>），<code>wget</code>可以打开并保存（通常用于下载文件），<code>git clone</code>可以下载项目源代码（去github&#x2F;gitee逛逛？），<code>ls -lh</code>可以显示更详细的信息</p><h2 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h2><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><p>上面已经安装了python，直接输入命令<code>python</code>即可进入交互模式，运行<code>exit()</code>退出。Termux支持<code>pip</code>安装拓展库，但由于平台兼容性问题，如果库依赖本地代码就需要在本地编译构建，很有可能装个几十分钟然后报错退出。目前发现可用的包有<code>sympy</code>（代数系统），<code>pwntools</code>（pwn手工具，部分需编译，要安装十几分钟分钟，现在好像装不上了QAQ），<code>numpy</code>（需要安装cmake并编译几十分钟），<code>jupyterlab</code>，<code>matplotlib</code>，<code>pillow</code>（但需要补全一些运行库，挺麻烦的）。<code>scipy</code>，<code>pandas</code>等由于某些原因装不上。</p><h3 id="C-x2F-C"><a href="#C-x2F-C" class="headerlink" title="C&#x2F;C++"></a>C&#x2F;C++</h3><p>上面已经安装了<code>g++</code>，接下来就可以用<code>vim a.cpp</code>写代码，然后用<code>g++ a.cpp</code>的形式编译源代码（多个文件参与编译就把要编译的文件都在后面加上）。带上<code>-g</code>参数生成调试信息方便debug，<code>-O2</code>开启优化，<code>-o 文件名</code>可以更改输出文件名。编译完成后当前目录会多出一个绿色的可执行文件（默认叫a.out，不要在意后缀，Linux可执行文件后缀不重要），输入<code>./a.out</code>即可执行。这里需要明确程序路径，这是因为Linux终端查找程序的范围不包括当前文件夹。</p><p>用<code>gdb a.exe</code>打开<code>gdb</code>调试器。<code>l</code>可以列出源代码，<code>l a.cpp:0</code>形式可指定文件和行号（多文件编译时有用）；<code>b</code>接数字可以打断点；<code>r</code>运行程序；<code>n</code>跳过语句（多次执行同一条命令不需要重复输入，直接回车即可）；<code>s</code>进入语句；<code>p</code>接表达式打印变量；<code>c</code>继续执行；<code>q</code>退出gdb。</p><h3 id="其他语言"><a href="#其他语言" class="headerlink" title="其他语言"></a>其他语言</h3><p>Termux支持很多语言，包括Java、nodejs、rust、haskell、golang等，安装方式与普通Linux无异</p><h2 id="解锁更多新姿势"><a href="#解锁更多新姿势" class="headerlink" title="解锁更多新姿势"></a>解锁更多新姿势</h2><h3 id="利用Jupyter-Lab在有图形的IDE上开发"><a href="#利用Jupyter-Lab在有图形的IDE上开发" class="headerlink" title="利用Jupyter Lab在有图形的IDE上开发"></a>利用Jupyter Lab在有图形的IDE上开发</h3><p>安装python后，用<code>pip install jupyterlab</code>可以安装jupyter lab，这是一个将python代码和markdown注释结合起来的神器ide，由于其通过Web服务器的形式提供GUI，其使用体验除了不能自动打开浏览器外和普通Linux上无异。不过你要先禁止对Termux的电池优化，否则切出Termux后它很快就被休眠乃至清除了（经测试我手机会在十秒后使其休眠）。另外手机显示PC的界面布局很不好看，面向PC的按键系统对触控也很不友好，如果真的要用，建议配合平板和蓝牙键鼠使用。由于Termux很难调用GPU，python库有些也很难装上，所以Jupyter+Python并不太好用（这方面AidLux会更优秀，但它太重了QAQ）；貌似Jupyter也支持其他语言，我没试过，也许可以。</p><h3 id="利用ffmpeg和Python处理视频图片"><a href="#利用ffmpeg和Python处理视频图片" class="headerlink" title="利用ffmpeg和Python处理视频图片"></a>利用ffmpeg和Python处理视频图片</h3><p>开源软件<code>ffmpeg</code>是很多剪辑软件的内核，其功能强大，可以完成音频视频图片的格式转换、裁切、剪辑、打水印等各种操作，但操作完全命令行，比较难学。<br>Python有pillow库来执行更多图片处理命令，不过因为Termux缺少图形库，这个比较难装。</p><h3 id="口袋里的计算机实验室"><a href="#口袋里的计算机实验室" class="headerlink" title="口袋里的计算机实验室"></a>口袋里的计算机实验室</h3><p>Termux还可以用来进行一些网络安全或计算机组成原理的实验。比如<code>nmap</code>、<code>radara2</code>等软件都是可以使用的</p><h3 id="无限的探索空间"><a href="#无限的探索空间" class="headerlink" title="无限的探索空间"></a>无限的探索空间</h3><p>总之吧，Termux就是给了你接触安卓底层的机会，你终于可以不用被App开发者牵着鼻子走啦！接下来，用Termux搭服务器之类的无限潜力就可以由我们慢慢发掘探索啦！</p>]]></content>
    
    
    <summary type="html">教你用Termux开启安卓终端</summary>
    
    
    
    <category term="折腾实录" scheme="https://mrcer.gitee.io/Blog/categories/%E6%8A%98%E8%85%BE%E5%AE%9E%E5%BD%95/"/>
    
    
    <category term="Linux" scheme="https://mrcer.gitee.io/Blog/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>自学资源分享</title>
    <link href="https://mrcer.gitee.io/Blog/2022/02/08/%E8%87%AA%E5%AD%A6%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/"/>
    <id>https://mrcer.gitee.io/Blog/2022/02/08/%E8%87%AA%E5%AD%A6%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/</id>
    <published>2022-02-08T11:16:38.000Z</published>
    <updated>2024-11-06T02:42:10.286Z</updated>
    
    <content type="html"><![CDATA[<p>这是一则我自学及开发使用的资源的分享，，希望对你有帮助~</p><h1 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h1><h2 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a><a href="https://code.visualstudio.com/">Visual Studio Code</a></h2><p>微软家的全能编辑器，免费开源、好看易用、启动迅速，支持Windows和Linux。需要注意的是VS Code不是一个ide，这意味着它本身是不能编译程序的。然而这也意味着只需要经过简单（大概？）的配置，你就可以用它做任何事情，包括编写任何语言的程序和写博客（对我现在就在用VS Code）。<br><img src="vscode.png" width="50%"/><br>你可以在<a href="https://blog.gztime.cc/posts/2020/6b9b4626/#%E5%89%8D%E8%A8%80">gz的博客</a>那里学会简单的配置。</p><p>VSCode最厉害的地方在于他有一个庞大的拓展库，你可以在里面找到各种东西。比如说你看到上面的插图中有一只魔理沙，那个是background插件，其他的还有各种语言配套的语言插件啦，用AI来完成自动补全的Tabnice插件啦，二进制文件查看的hexdump啦，写博客用markdown语言有Markdown All in One插件啦。总之有了VSCode，其他编辑器我都再也没用啦！</p><h2 id="Visual-Studio"><a href="#Visual-Studio" class="headerlink" title="Visual Studio"></a><a href="https://visualstudio.microsoft.com/zh-hans/">Visual Studio</a></h2><p>Visual Studio是微软家的IDE，可以开发.NET、C++等等。与VSCode不同的是，VS是以项目为单位来开发的，而VSCode一般以文件为单位编译运行，同时VS本身就包含了IDE应有的编译、调试、打包等功能。然而，这些功能的代价是庞大的安装体积和较慢的启动速度。</p><p>一般我小的项目我都会用VSCode，只有项目太大，需要链接库之类的时候我才会用VSCode，比如学习OpenGL。</p><p>既然说到IDE我顺便把其他的也说了吧，毕竟那些都是在开发相应程序的时候才需要了解的，就不单独说啦。比如开发Java可以用<a href="https://www.jetbrains.com/idea/">Intellij idea</a>（只在开发MC模组的时候用），开发Python可以用<a href="https://www.jetbrains.com/pycharm/">PyCharm</a>（没用过），开发安卓应用可以用<a href="https://developer.android.google.cn/studio/">Android Studio</a>（没咋用过，倒是AIDE用过）等等。</p><h2 id="菜鸟教程"><a href="#菜鸟教程" class="headerlink" title="菜鸟教程"></a><a href="https://www.runoob.com/">菜鸟教程</a></h2><p>我首选的学习语言的网站。这个网站优点就在于主要的语言乃至一些技术都有教程，而且还是中文！不仅如此，网站内容意简言赅，没有半句废话，特别适合有经验的人学习新语言。然而这个网站部分内容存在过时（比如Python教程就是2&#x2F;3混在一起的），有些内容因为精简也省略了，还有大部分库都没有详细的介绍。如果你需要了解一门语言的具体技术细节的话不妨参考文档，比如<a href="https://www.cplusplus.com/reference/">c++ reference</a>，<a href="https://www.python.org/doc/">Python文档</a>等等。不过你要做好啃生肉的准备。</p><p>两年后的补充：菜鸟教程只是相对较好，推荐在学习任何东西之前 <strong>先看文档</strong>，作为一手资料，大部分情况下都会比二手资料好。下面是让文档不那么可怕的一些指引：</p><ol><li>请务必区分一下概念：<ul><li>文档 Documentation：统称每个项目包含的代码外的文字说明</li><li>参考 Reference：罗列出库里每个接口的用法</li><li>教程 Tutorial：面向初学者的指南<br> 很显然我们应当选择文档下的教程</li></ul></li><li>如果你看到教程是英文的，请首先查看是否有语言选择菜单，如果没有，请查看是否有社区翻译版本</li></ol><h2 id="bilibili"><a href="#bilibili" class="headerlink" title="bilibili"></a><a href="https://www.bilibili.com/">bilibili</a></h2><p>是的，B站大学实至名归，从编程到电焊，从医学到数学，你能找到各种学习内容，这里简单分享几个：</p><ol><li>3Blue1Brown：分享数学知识的up主，我线代96分，一半是他教的。不下饭，要经常暂停。</li><li>硬件茶谈：分享硬核硬件常识的up主，看完你就能自己装电脑了。</li><li>稚晖君：告诉你学霸可以做到什么地步</li><li>LinusTechTips：老莱的计算机科普，教你各种计算机相关的冷知识</li><li>极客湾Geekerwan：硬件评测，是个折腾的up主，让你能紧跟时代潮流，看懂最新硬件。</li><li>BranchEducation：一个介绍计算机原理的新up，看起来可视化有点东西，可以了解一下</li><li>Chubbyemu：分享临床医学案例的up主，很下饭，还能教你基本的医学常识</li><li>学院派Academia：分享社科知识的up主，非常硬核，下饭催眠都很好用</li><li>罗翔说刑法：教法律知识的，下饭，也能培养三观</li><li>人民医学：简单的医学科普</li><li>爱上半导体：电子信息专业的可以看看，讲半导体相关的，可视化做得不错</li><li>六层楼先生：妇产科医生，性科普做得不错</li><li>阿林吃土：教做饭的，小白入门级</li></ol><p>还有一些泛科普的、教音乐美术的、教建模的、教特效剪辑的、教游戏理论的、教物理化学的、教历史的、甚至教昆虫的、教你学习的。想了解的可以关注我B站号：深海菠萝小狮子。</p><p>值得一提的是，B站的科普是面向所有人的，优点是可视化程度高，以视频形式展现容易看懂，但缺点也很明显：</p><ol><li>很少有系统讲解知识的，大部分都是简化过的知识，只可以当做初步了解。</li><li>科普up的知识也是有限的，也许会有错误内容，甚至有的up会夹带私货，观看时要时刻保持辩证思维。</li><li>up主为了恰饭有时需要打广告。</li></ol><p>如果你真的想系统学习某种知识，你最好找那种分十几p的视频，或者直接去中国大学mooc学。</p><p>两年后的补充：B站大学变化快速，上面的 up 主有些已经转变方向，仅供参考。作为流媒体平台，大部分 up 难免娱乐性质更重，不要期待太高。</p><h2 id="Termux"><a href="#Termux" class="headerlink" title="Termux"></a><a href="https://termux.com/">Termux</a></h2><p>一个运行在安卓上的Linux终端。使用这个软件你可以在手机上写程序、跑代码、连接服务器、学习Linux、装逼等等。终端，也就是说没有图形界面，同时自带的Linux系统也是非常简洁的（软件包才97M），你需要安装许多软件，非常折腾。如果你不想折腾，<a href="https://www.aidlux.com/">AidLearning</a>可能也不错，预装了完整的系统和各种软件，不过占用空间非常大，也比较卡，让本来就不太实用的东西更不实用了哈哈哈（当然主要是软件不会用）。</p><p>这里简单说一下这个软件怎么用吧，以后还会写折腾笔记的。</p><p>你首先得先学会Linux的基本操作，这个菜鸟教程有，包括目录操作命令、新建复制粘贴软件安装命令（软件自带pkg作为包管理器，apt也行）。然后安装vim作为文本编辑器，需要开发C++的话装g++，需要运行python就装python之类的。你还能用nmap扫端口（不过官网说软件库不提供黑客工具，你得自己整），ping服务器，查看网络设置等等。</p><p>当然如果你只是想学Linux的话还有很多选择，最简单的就是WSL，也可以像我以前大佬那样塞个系统进U盘，也不是不行。</p><h2 id="Jupyter"><a href="#Jupyter" class="headerlink" title="Jupyter"></a>Jupyter</h2><p>你想学习Python的库吗？快用Jupyter！这种全新的交互方式将markdown和python结合在一起，让你的学习笔记能跑代码。来，直接上图！<br><img src="Jupyter.png" width="80%"/></p><p>这个博客是零基础的，这里简单介绍一下markdown和python。</p><p>Markdown是一个轻量级的标记语言，你可以理解为超简单的word。首先，用MD你就不需要鼠标了，标题直接用<code>#</code>，多少级标题就用多少个<code>#</code>，你不需要调字体大小；加粗斜体都用<code>*</code>；还有插入链接、代码框、注释等都是非常方便的。插入数学公式、插入图片、插入表格当然也能做到，不过有点小麻烦，可以用一些对应的工具来简化。MD本身是个纯文本文件，需要渲染器才能显示效果，你可以理解为源文件和编译。btw，这篇博客基本上就是用Markdown写的。<br><img src="md.png" width="80%"/></p><p>Python是一个简单的脚本语言，但是很多东西都能干。当然，这样强大的功能是依赖库的，比如你学会Sympy就能完成很多平常要在Matlab完成的操作，学会Pillow就可以用代码处理图片，还有人工智能很多都是有Python接口的。</p><p>安装也很简单，先装个python，然后命令行跑个<code>pip install jupyterlab</code>安装jupyter和更好看的前端界面，完成。接下来命令行运行<code>jupyter lab</code>你就启动了jupyter服务器了，读一下命令行的文字，用浏览器打开那个网址，你就进入到jupyter了。如果你想用更接近你平常用软件的方式工作的话，VSCode有Jupyter插件，你装好python和jupyter之后再打开VSCode装Jupyter插件就可以像打开一个普通文件一样打开<code>.ipynb</code>的notebook文件了。</p><h2 id="一些其他的网站"><a href="#一些其他的网站" class="headerlink" title="一些其他的网站"></a>一些其他的网站</h2><ol><li><a href="https://www.kaggle.com/">kaggle</a>：一个学习机器学习的网站</li><li><a href="https://leetcode-cn.com/">leetcode</a>：刷题网站，不多说</li><li><a href="https://ctf-wiki.org/">ctf-wiki</a>：学习CTF技能的</li><li><a href="https://oi-wiki.org/">oi-wiki</a>：学算法的</li></ol><p>（未完待续，咕咕咕）（续的话大概是完全重写吧）</p>]]></content>
    
    
    <summary type="html">这是一则我自学及开发使用的资源的分享，希望对你有帮助~</summary>
    
    
    
    
    <category term="资源分享" scheme="https://mrcer.gitee.io/Blog/tags/%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
</feed>
